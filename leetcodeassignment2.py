# -*- coding: utf-8 -*-
"""leetcodeAssignment2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NwenzWS_6VjMoNSbo_7XlCCzEw_BuAiv

Given a string s consisting of words and spaces, return the length of the last word in the string.

A word is a maximal
substring
 consisting of non-space characters only.
"""

class Solution(object):
    def lengthOfLastWord(self, s):
        self.s=s
        x=s.split()[-1]
        return len(x)

obj=Solution()
s="Barking dog seldom"
obj.lengthOfLastWord(s)

"""Given a string s, return the string after replacing every uppercase letter with the same lowercase letter.


"""

class Solution(object):
    def toLowerCase(self, s):
        self.s=s
        return s.lower()

obj=Solution()
s="Hello WORLD"
obj.toLowerCase(s)

"""You are keeping the scores for a baseball game with strange rules. At the beginning of the game, you start with an empty record.

You are given a list of strings operations, where operations[i] is the ith operation you must apply to the record and is one of the following:

An integer x. :Record a new score of x.
'+':Record a new score that is the sum of the previous two scores.
'D':Record a new score that is the double of the previous score.
'C':Invalidate the previous score, removing it from the record.

Return the sum of all the scores on the record after applying all the operations.

The test cases are generated such that the answer and all intermediate calculations fit in a 32-bit integer and that all operations are valid.
"""

class Solution(object):
    def calPoints(self, operations):
      output=[]
      for i in operations:
        if i=="+":
          output.append(output[-1]+output[-2])
        elif i=="D":
          output.append(2*output[-1])
        elif i=="C":
          output.pop()
        else:
          output.append(int(i))

      return sum(output)


obj=Solution()
ops =["5","2","C","D","+"]
obj.calPoints(ops)

"""There is a robot starting at the position (0, 0), the origin, on a 2D plane. Given a sequence of its moves, judge if this robot ends up at (0, 0) after it completes its moves.

You are given a string moves that represents the move sequence of the robot where moves[i] represents its ith move. Valid moves are 'R' (right), 'L' (left), 'U' (up), and 'D' (down).

Return true if the robot returns to the origin after it finishes all of its moves, or false otherwise.

Note: The way that the robot is "facing" is irrelevant. 'R' will always make the robot move to the right once, 'L' will always make it move left, etc. Also, assume that the magnitude of the robot's movement is the same for each move.


"""

class Solution(object):
    def judgeCircle(self, moves):
      o=[0,0]
      for i in moves:
        if i=="L":
          o[0]-=1
        elif i=="R":
          o[0]+=1
        elif i=="U":
          o[1]+=1
        elif i=="D":
          o[1]-=1

      if o[0]==0 and o[1]==0:
        return True
      else:
        return False


obj=Solution()
moves = "LL"
obj.judgeCircle(moves)

"""Tic-tac-toe is played by two players A and B on a 3 x 3 grid. The rules of Tic-Tac-Toe are:

Players take turns placing characters into empty squares ' '.
The first player A always places 'X' characters, while the second player B always places 'O' characters.
'X' and 'O' characters are always placed into empty squares, never on filled ones.
The game ends when there are three of the same (non-empty) character filling any row, column, or diagonal.
The game also ends if all squares are non-empty.
No more moves can be played if the game is over.
Given a 2D integer array moves where moves[i] = [rowi, coli] indicates that the ith move will be played on grid[rowi][coli]. return the winner of the game if it exists (A or B). In case the game ends in a draw return "Draw". If there are still movements to play return "Pending".

You can assume that moves is valid (i.e., it follows the rules of Tic-Tac-Toe), the grid is initially empty, and A will play first.


"""

class Solution(object):
    def tictactoe(self, moves):
      grid = [[''] * 3 for _ in range(3)]
      player = 'A'

      for move in moves:
        row, col = move
        grid[row][col] = player

      # Check if the current player has won after placing the move
        if (grid[row][0] == grid[row][1] == grid[row][2] == player or
           grid[0][col] == grid[1][col] == grid[2][col] == player or
           grid[0][0] == grid[1][1] == grid[2][2] == player or
           grid[0][2] == grid[1][1] == grid[2][0] == player):
          return player

      # Switch player for the next move
        player = 'B' if player == 'A' else 'A'

      # Check if the game is pending or if it ended in a draw
      if len(moves) < 9:
        return "Pending"
      else:
        return "Draw"



obj=Solution()
moves =[[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]]
obj.tictactoe(moves)

"""On an infinite plane, a robot initially stands at (0, 0) and faces north. Note that:

The north direction is the positive direction of the y-axis.
The south direction is the negative direction of the y-axis.
The east direction is the positive direction of the x-axis.
The west direction is the negative direction of the x-axis.
The robot can receive one of three instructions:

"G": go straight 1 unit.
"L": turn 90 degrees to the left (i.e., anti-clockwise direction).
"R": turn 90 degrees to the right (i.e., clockwise direction).
The robot performs the instructions given in order, and repeats them forever.

Return true if and only if there exists a circle in the plane such that the robot never leaves the circle.


"""

class Solution(object):
    def isRobotBounded(self, instructions):
        # Possible directions: north, east, south, west
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        x, y = 0, 0
        # Start from north
        current_direction = 0
        for instruction in instructions:
          if instruction == 'G':
            dx, dy = directions[current_direction]
            x += dx
            y += dy
          elif instruction == 'L':
            current_direction = (current_direction - 1) % 4
          elif instruction == 'R':
            current_direction = (current_direction + 1) % 4
        # Check if either it returns to the origin or ends up facing north after the sequence
        return (x == 0 and y == 0) or current_direction != 0


obj=Solution()
instructions="GLGR"
obj.isRobotBounded(instructions)

"""You are given an m x n integer grid accounts where accounts[i][j] is the amount of money the i​​​​​​​​​​​th​​​​ customer has in the j​​​​​​​​​​​th​​​​ bank. Return the wealth that the richest customer has.

A customer's wealth is the amount of money they have in all their bank accounts. The richest customer is the customer that has the maximum wealth.


"""

class Solution(object):
    def maximumWealth(self, accounts):
        max_wealth = 0

        for customer in accounts:
            wealth = sum(customer)
            if wealth>max_wealth:
              i=accounts.index(customer)
              max_wealth=wealth
        return max_wealth,i


obj=Solution()
accounts = [[1,5],[7,3],[3,5]]
w,i=obj.maximumWealth(accounts)
print("Maximum wealth is for ",i+1,"th person and the wealth is",w)

"""Given a square matrix mat, return the sum of the matrix diagonals.

Only include the sum of all the elements on the primary diagonal and all the elements on the secondary diagonal that are not part of the primary diagonal.


"""

class Solution(object):
    def diagonalSum(self, mat):
        n = len(mat)
        diagonal_sum = 0

        for i in range(n):
          diagonal_sum += mat[i][i]  # Add elements from the primary diagonal
          diagonal_sum += mat[i][n - 1 - i] if i != n - 1 - i else 0  # Add elements from the secondary diagonal (excluding the center if it's on both diagonals)

        return diagonal_sum

obj=Solution()
mat = [[1,2,3],
       [4,5,6],
       [7,8,9]]

obj.diagonalSum(mat)

"""Given an m x n matrix, return all elements of the matrix in spiral order."""

class Solution(object):
    def spiralOrder(self, matrix):
      result = []
      while matrix:
        result += matrix.pop(0)  # Add the first row
        if matrix and matrix[0]:
          for row in matrix:
            result.append(row.pop())  # Add the last element of each remaining row
          if matrix[-1]:  # Add the last row in reverse
            result += matrix.pop()[::-1]
          if matrix:  # Add the first element of each remaining row in reverse
            for row in matrix[::-1]:
              result.append(row.pop(0))
      return result

obj=Solution()
matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
obj.spiralOrder(matrix)

"""Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's"""

class Solution(object):
    def setZeroes(self, matrix):
        if not matrix or not matrix[0]:
          return matrix

        rows, cols = len(matrix), len(matrix[0])
        zero_rows, zero_cols = set(), set()

        # Mark rows and columns that need to be zeroed out
        for i in range(rows):
          for j in range(cols):
            if matrix[i][j] == 0:
              zero_rows.add(i)
              zero_cols.add(j)

        # Set entire rows to zeros
        for row in zero_rows:
          for j in range(cols):
            matrix[row][j] = 0

      # Set entire columns to zeros
        for col in zero_cols:
          for i in range(rows):
            matrix[i][col] = 0

        return matrix



obj=Solution()
matrix = [[1,1,1],[1,0,1],[1,1,1]]
obj.setZeroes(matrix)

"""Given two non-negative integers low and high. Return the count of odd numbers between low and high (inclusive).


"""

class Solution(object):
    def countOdds(self, low, high):
       self.low=low
       self.high=high
       count=0
       for i in range(low,high+1):
        if i%2 !=0:
          count+=1

       return count

obj=Solution()
low=3
high=10
obj.countOdds(low,high)

"""You are given an array of unique integers salary where salary[i] is the salary of the ith employee.

Return the average salary of employees excluding the minimum and maximum salary. Answers within 10-5 of the actual answer will be accepted.
"""

class Solution(object):
    def average(self, salary):
      self.salary=salary
      salary.remove(min(salary))
      salary.remove(max(salary))
      avg=sum(salary)/len(salary)
      return avg

obj=Solution()
salary = [1000,2000,3000]
obj.average(salary)

"""At a lemonade stand, each lemonade costs $5. Customers are standing in a queue to buy from you and order one at a time (in the order specified by bills). Each customer will only buy one lemonade and pay with either a $5, $10, or $20 bill. You must provide the correct change to each customer so that the net transaction is that the customer pays $5.

Note that you do not have any change in hand at first.

Given an integer array bills where bills[i] is the bill the ith customer pays, return true if you can provide every customer with the correct change, or false otherwise.
"""

class Solution(object):
    def lemonadeChange(self, bills):
      five = ten = 0

      for bill in bills:
        if bill == 5:
            five += 1
        elif bill == 10:
            if five == 0:
                return False
            five -= 1
            ten += 1
        else:  # For $20 bills
            if ten > 0 and five > 0:
                ten -= 1
                five -= 1
            elif five >= 3:
                five -= 3
            else:
                return False

      return True


obj=Solution()
bills = [5,5,5,10,20]
obj.lemonadeChange(bills)

"""Given an integer array nums, return the largest perimeter of a triangle with a non-zero area, formed from three of these lengths. If it is impossible to form any triangle of a non-zero area, return 0."""

class Solution(object):
    def largestPerimeter(self, nums):
       nums.sort(reverse=True)

       for i in range(len(nums) - 2):
        if nums[i] < nums[i + 1] + nums[i + 2]:
          return nums[i] + nums[i + 1] + nums[i + 2]

       return 0


obj=Solution()
nums = [2,1,2]
obj.largestPerimeter(nums)

"""You are given an array coordinates, coordinates[i] = [x, y], where [x, y] represents the coordinate of a point. Check if these points make a straight line in the XY plane.


"""

class Solution(object):
    def checkStraightLine(self, coordinates):
      m=(coordinates[1][1]-coordinates[0][1])/(coordinates[1][0]-coordinates[0][0])
      for i in range(1,len(coordinates)):
        if ((coordinates[i+1][1]-coordinates[i][1])/(coordinates[i+1][0]-coordinates[i][0]))!=m:
          return False
        else:
          return True

obj=Solution()
coordinates=[[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]
obj.checkStraightLine(coordinates)

"""Given two binary strings a and b, return their sum as a binary string."""

class Solution(object):
    def addBinary(self, a, b):
      result = ""
      carry = 0
      # Make both strings of equal length by padding zeros to the left
      maxLength = max(len(a), len(b))
      a = a.zfill(maxLength)
      b = b.zfill(maxLength)

      # Traverse the strings from right to left
      for i in range(maxLength - 1, -1, -1):
        sum_val = int(a[i]) + int(b[i]) + carry
        result = str(sum_val % 2) + result
        carry = sum_val // 2

      # If there's a remaining carry, add it to the result
      if carry:
        result = "1" + result

      return result

obj=Solution()
a = "1010"
b = "1011"
obj.addBinary(a,b)

"""Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string."""

class Solution(object):
    def multiply(self, num1, num2):
      num1 = [int(digit) for digit in reversed(num1)]
      num2 = [int(digit) for digit in reversed(num2)]

      # Initialize a result list to store intermediate products
      result = [0] * (len(num1) + len(num2))

      # Perform multiplication digit by digit
      for i in range(len(num1)):
        for j in range(len(num2)):
          result[i + j] += num1[i] * num2[j]
          result[i + j + 1] += result[i + j] // 10
          result[i + j] %= 10

      # Remove leading zeros and convert the result list back to a string
      while len(result) > 1 and result[-1] == 0:
        result.pop()

      return ''.join(map(str, reversed(result)))


obj=Solution()
num1 = "123"
num2 = "456"
obj.multiply(num1,num2)

"""Implement pow(x, n), which calculates x raised to the power n (i.e., xn).


"""

class Solution(object):
    def myPow(self, x, n):
      if n == 0:
        return 1.0

      if n < 0:
        x = 1 / x
        n = -n

      result = 1.0
      while n > 0:
        if n % 2 == 1:
          result *= x
        x *= x
        n //= 2

      return result


obj=Solution()
x = 2.10000
n = 3
obj.myPow(x,n)

